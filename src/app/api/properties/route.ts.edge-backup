import { NextRequest, NextResponse } from 'next/server'
import { supabase } from '@/lib/db'
import { requireUser } from '@/lib/auth'
import { PropertyCreateSchema, PropertyQuerySchema } from '@/schemas/property'
import { sanitizeAndValidate } from '@/lib/sanitize'
import { logger } from '@/lib/logger'
import { checkRateLimit } from '@/lib/rate-limit'
import { validateCSRFToken } from '@/lib/csrf'
import { mapPropertyFromDB, mapPropertyToDB, type Property, type PropertyDB, type CountryEnum } from '@/types/properties'
import { buildiumSync } from '@/lib/buildium-sync'

export async function POST(request: NextRequest) {
  try {
    // Rate limiting
    const rateLimit = await checkRateLimit(request);
    if (!rateLimit.success) {
      return NextResponse.json(
        { error: 'Too many requests', retryAfter: rateLimit.retryAfter },
        { status: 429 }
      );
    }

    // CSRF protection
    const isValidCSRF = await validateCSRFToken(request);
    console.log('CSRF validation result:', isValidCSRF);
    console.log('Request headers:', Object.fromEntries(request.headers.entries()));
    console.log('Request cookies:', request.cookies.getAll());
    
    if (!isValidCSRF) {
      return NextResponse.json(
        { error: 'Invalid CSRF token' },
        { status: 403 }
      );
    }

    // Authentication
    const user = await requireUser(request);
    logger.info({ userId: user.id, action: 'create_property' }, 'Creating property');

    // Parse and validate request body
    let body;
    try {
      body = await request.json();
    } catch (parseError) {
      logger.error({ error: parseError }, 'Failed to parse request body');
      return NextResponse.json(
        { error: 'Invalid JSON in request body' },
        { status: 400 }
      );
    }
    
    console.log('Received request body:', body);
    const data = sanitizeAndValidate(body, PropertyCreateSchema);
    console.log('Validated data:', data);

    // Map to database format
    const dbData = mapPropertyToDB({
      name: data.name,
      structureDescription: data.structureDescription,
      addressLine1: data.addressLine1,
      city: data.city,
      state: data.state,
      postalCode: data.postalCode,
      country: data.country as CountryEnum,
      rentalSubType: data.rentalSubType,
      operatingBankAccountId: data.operatingBankAccountId || undefined,
      reserve: data.reserve,
      yearBuilt: data.yearBuilt ? parseInt(data.yearBuilt) : undefined,
      status: 'Active'
    });

    // Add required timestamp fields
    const now = new Date().toISOString();
    const finalDbData = {
      ...dbData,
      updated_at: now
    };

    console.log('Attempting to insert property with data:', finalDbData);
    
    // Create the property with transaction-like error handling
    const { data: property, error: propertyError } = await supabase
      .from('properties')
      .insert(finalDbData)
      .select()
      .single()

    if (propertyError) {
      console.error('Database error:', propertyError);
      logger.error({ error: propertyError, userId: user.id }, 'Failed to create property');
      return NextResponse.json(
        { error: 'Failed to create property', details: propertyError.message },
        { status: 500 }
      )
    }

    // Create ownership records if owners are provided
    if (data.owners && data.owners.length > 0) {
      const ownershipRecords = data.owners.map((owner) => ({
        owner_id: owner.id,
        property_id: property.id,
        ownership_percentage: owner.ownershipPercentage ? parseFloat(owner.ownershipPercentage.toString()) : null,
        disbursement_percentage: owner.disbursementPercentage ? parseFloat(owner.disbursementPercentage.toString()) : null,
        primary: owner.primary || false
      }))

      const { error: ownershipError } = await supabase
        .from('ownerships')
        .insert(ownershipRecords)

      if (ownershipError) {
        logger.error({ error: ownershipError, propertyId: property.id }, 'Failed to create ownership records');
        // Note: In a production system, you might want to rollback the property creation
        // For now, we'll log the error but continue
      }

      // primary_owner field removed - ownership is now managed through ownerships table
    }

    // Create property staff record if property manager is assigned
    if (data.propertyManagerId) {
      await supabase
        .from('PropertyStaff')
        .insert({
          propertyId: property.id,
          staffId: data.propertyManagerId,
          role: 'PROPERTY_MANAGER'
        })
    }

    // ============================================================================
    // BUILDIUM SYNC - NEW SECTION
    // ============================================================================

    let buildiumSyncResult = { success: true, buildiumId: undefined, error: undefined };

    try {
      // Prepare property data for Buildium sync
      const buildiumPropertyData = {
        Name: property.name,
        PropertyType: mapPropertyTypeToBuildium(property.rental_sub_type),
        Address: {
          AddressLine1: property.address_line1,
          AddressLine2: property.address_line2 || undefined,
          City: property.city || '',
          State: property.state || '',
          PostalCode: property.postal_code,
          Country: property.country
        },
        YearBuilt: property.year_built || undefined,
        SquareFootage: property.square_footage || undefined,
        Bedrooms: property.bedrooms || undefined,
        Bathrooms: property.bathrooms || undefined,
        IsActive: property.is_active !== false,
        Description: property.structure_description || undefined,
        OperatingBankAccountId: property.operating_bank_account_id || undefined,
        Reserve: property.reserve || undefined
      };

      // Sync to Buildium
      buildiumSyncResult = await buildiumSync.syncPropertyToBuildium(buildiumPropertyData);

      if (buildiumSyncResult.success && buildiumSyncResult.buildiumId) {
        logger.info({ 
          propertyId: property.id, 
          buildiumId: buildiumSyncResult.buildiumId,
          userId: user.id 
        }, 'Property successfully synced to Buildium');
      } else if (!buildiumSyncResult.success) {
        logger.warn({ 
          propertyId: property.id, 
          error: buildiumSyncResult.error,
          userId: user.id 
        }, 'Property created locally but Buildium sync failed');
      }

    } catch (syncError) {
      logger.error({ 
        propertyId: property.id, 
        error: syncError,
        userId: user.id 
      }, 'Error during Buildium sync');
      
      buildiumSyncResult = { 
        success: false, 
        buildiumId: undefined, 
        error: syncError instanceof Error ? syncError.message : 'Unknown sync error' 
      };
    }

    // Map response back to application format
    const mappedProperty = mapPropertyFromDB(property as PropertyDB);

    console.log('Property created successfully:', { 
      propertyId: property.id, 
      userId: user.id,
      buildiumSyncSuccess: buildiumSyncResult.success,
      buildiumId: buildiumSyncResult.buildiumId
    });

    return NextResponse.json(
      { 
        message: 'Property created successfully',
        property: mappedProperty,
        buildiumSync: {
          success: buildiumSyncResult.success,
          buildiumId: buildiumSyncResult.buildiumId,
          error: buildiumSyncResult.error
        }
      },
      { status: 201 }
    )

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHENTICATED') {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    console.error('Error creating property:', error instanceof Error ? error.message : 'Unknown error');
    return NextResponse.json(
      { error: 'Failed to create property' },
      { status: 500 }
    )
  }
}

export async function GET(request: NextRequest) {
  try {
    // Rate limiting
    const rateLimit = await checkRateLimit(request);
    if (!rateLimit.success) {
      return NextResponse.json(
        { error: 'Too many requests', retryAfter: rateLimit.retryAfter },
        { status: 429 }
      );
    }

    // Authentication
    const user = await requireUser(request);
    console.log('Fetching properties:', { userId: user.id, action: 'fetch_properties' });

    // Parse and validate query parameters
    const url = new URL(request.url);
    const queryParams = Object.fromEntries(url.searchParams.entries());
    const query = sanitizeAndValidate(queryParams, PropertyQuerySchema);

    // Build query with pagination and filters
    let queryBuilder = supabase
      .from('properties')
      .select(`
        id,
        name,
        address_line1,
        city,
        state,
        postal_code,
        country,
        rental_sub_type,
        status,
        buildium_property_id,
        buildium_created_at,
        buildium_updated_at,
        created_at,
        updated_at
      `)
      .range(query.offset, query.offset + query.limit - 1);

    // Apply filters
    if (query.status) {
      queryBuilder = queryBuilder.eq('status', query.status);
    }
    if (query.type) {
      queryBuilder = queryBuilder.eq('rental_sub_type', query.type);
    }
    if (query.search) {
      queryBuilder = queryBuilder.or(`name.ilike.%${query.search}%,address_line1.ilike.%${query.search}%`);
    }

    const { data: properties, error } = await queryBuilder;

    if (error) {
      console.error('Error fetching properties:', { error, userId: user.id });
      return NextResponse.json(
        { error: 'Failed to fetch properties' },
        { status: 500 }
      )
    }

    // Map database results to application format
    const mappedProperties = properties?.map((dbProperty) => mapPropertyFromDB({
      ...dbProperty,
      operating_bank_account_id: null, // Default value for required field
      rental_owner_ids: [],
      total_units: 0 // Default value for required field
    } as PropertyDB)) || [];

    console.log('Properties fetched successfully:', { count: mappedProperties.length, userId: user.id });
    return NextResponse.json(mappedProperties)
  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHENTICATED') {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    logger.error({ error: error instanceof Error ? error.message : 'Unknown error' }, 'Error fetching properties');
    return NextResponse.json(
      { error: 'Failed to fetch properties' },
      { status: 500 }
    )
  }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

function mapPropertyTypeToBuildium(localType: string): 'Rental' | 'Association' | 'Commercial' {
  switch (localType) {
    case 'Office':
    case 'Retail':
    case 'ShoppingCenter':
    case 'Storage':
    case 'ParkingSpace':
      return 'Commercial'
    default:
      return 'Rental'
  }
}
