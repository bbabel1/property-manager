import { NextRequest, NextResponse } from 'next/server'
import { supabase, supabaseAdmin } from '@/lib/db'
import { requireUser } from '@/lib/auth'
import { logger } from '@/lib/logger'
import { checkRateLimit } from '@/lib/rate-limit'
import { sanitizeAndValidate } from '@/lib/sanitize'
import { OwnerCreateSchema, OwnerQuerySchema } from '@/schemas/owner'

export async function GET(request: NextRequest) {
  try {
    console.log('🔍 Owners API: Starting request...');
    
    // Rate limiting
    const rateLimit = await checkRateLimit(request);
    if (!rateLimit.success) {
      console.log('🔍 Owners API: Rate limit exceeded');
      return NextResponse.json(
        { error: 'Too many requests', retryAfter: rateLimit.retryAfter },
        { status: 429 }
      );
    }

    console.log('🔍 Owners API: Rate limit check passed');

    // Authentication
    const user = await requireUser(request);
    console.log('🔍 Owners API: User authenticated:', user.id);
    
    // Validate query parameters
    const { searchParams } = new URL(request.url);
    const query = sanitizeAndValidate(Object.fromEntries(searchParams), OwnerQuerySchema);
    console.log('🔍 Owners API: Validated query parameters:', query);
    
    // Fetch owners from database with contact information and calculate total units
    console.log('🔍 Owners API: About to query Supabase...');
    
    const { data: owners, error } = await supabaseAdmin
      .from('owners')
      .select(`
        id,
        contact_id,
        management_agreement_start_date,
        management_agreement_end_date,
        comment,
        etf_account_type,
        etf_account_number,
        etf_routing_number,
        tax_payer_id,
        tax_payer_type,
        tax_payer_name,
        tax_address_line_1,
        tax_address_line_2,
        tax_address_line_3,
        tax_city,
        tax_state,
        tax_postal_code,
        tax_country,
        created_at,
        updated_at,
        contacts (
          id,
          is_company,
          first_name,
          last_name,
          company_name,
          display_name,
          primary_email,
          alt_email,
          primary_phone,
          alt_phone,
          date_of_birth,
          primary_address_line_1,
          primary_address_line_2,
          primary_address_line_3,
          primary_city,
          primary_state,
          primary_postal_code,
          primary_country,
          alt_address_line_1,
          alt_address_line_2,
          alt_address_line_3,
          alt_city,
          alt_state,
          alt_postal_code,
          alt_country,
          mailing_preference
        )
      `)
      .order('contacts(last_name)', { ascending: true })
      .order('contacts(first_name)', { ascending: true });

    // Calculate total units for each owner by summing total_units from their properties
    console.log('🔍 Owners API: Calculating total units for each owner...');
    const ownersWithTotalUnits = await Promise.all(
      owners?.map(async (owner) => {
        // Get all properties owned by this owner through ownerships table
        const { data: ownerships, error: ownershipError } = await supabaseAdmin
          .from('ownerships')
          .select(`
            property_id,
            properties (
              total_units
            )
          `)
          .eq('owner_id', owner.id);

        if (ownershipError) {
          console.error('🔍 Owners API: Error fetching ownerships for owner', owner.id, ownershipError);
          return { ...owner, total_units: 0 };
        }

        // Sum up total_units from all properties owned by this owner
        const totalUnits = ownerships?.reduce((sum, ownership) => {
          const property = Array.isArray(ownership.properties) ? ownership.properties[0] : ownership.properties;
          return sum + (property?.total_units || 0);
        }, 0) || 0;

        return { ...owner, total_units: totalUnits };
      }) || []
    );

    console.log('🔍 Owners API: Supabase query completed');
    console.log('🔍 Owners API: Error:', error);
    console.log('🔍 Owners API: Data count:', owners?.length || 0);

    if (error) {
      console.error('🔍 Owners API: Database error:', error);
      // Temporarily disable logger to avoid pino issues
      // logger.error({ error, userId: user.id }, 'Error fetching owners');
      return NextResponse.json(
        { error: 'Failed to fetch owners', details: error.message },
        { status: 500 }
      )
    }

    // Transform data to include a display name and flatten contact information
    console.log('🔍 Owners API: Transforming data...');
    const transformedOwners = ownersWithTotalUnits?.map(owner => {
      const contact = Array.isArray(owner.contacts) ? owner.contacts[0] : owner.contacts;
      return {
        id: owner.id,
        contact_id: owner.contact_id,
        management_agreement_start_date: owner.management_agreement_start_date,
        management_agreement_end_date: owner.management_agreement_end_date,
        comment: owner.comment,
        etf_account_type: owner.etf_account_type,
        etf_account_number: owner.etf_account_number,
        etf_routing_number: owner.etf_routing_number,
        created_at: owner.created_at,
        updated_at: owner.updated_at,
        // Contact information flattened
        is_company: contact?.is_company,
        first_name: contact?.first_name,
        last_name: contact?.last_name,
        company_name: contact?.company_name,
        display_name: contact?.display_name,
        primary_email: contact?.primary_email,
        alt_email: contact?.alt_email,
        primary_phone: contact?.primary_phone,
        alt_phone: contact?.alt_phone,
        date_of_birth: contact?.date_of_birth,
        primary_address_line_1: contact?.primary_address_line_1,
        primary_address_line_2: contact?.primary_address_line_2,
        primary_address_line_3: contact?.primary_address_line_3,
        primary_city: contact?.primary_city,
        primary_state: contact?.primary_state,
        primary_postal_code: contact?.primary_postal_code,
        primary_country: contact?.primary_country,
        alt_address_line_1: contact?.alt_address_line_1,
        alt_address_line_2: contact?.alt_address_line_2,
        alt_address_line_3: contact?.alt_address_line_3,
        alt_city: contact?.alt_city,
        alt_state: contact?.alt_state,
        alt_postal_code: contact?.alt_postal_code,
        alt_country: contact?.alt_country,
        mailing_preference: contact?.mailing_preference,
        // Tax information from owners table
        tax_payer_id: owner.tax_payer_id,
        tax_payer_type: owner.tax_payer_type,
        tax_payer_name: owner.tax_payer_name,
        tax_address_line_1: owner.tax_address_line_1,
        tax_address_line_2: owner.tax_address_line_2,
        tax_address_line_3: owner.tax_address_line_3,
        tax_city: owner.tax_city,
        tax_state: owner.tax_state,
        tax_postal_code: owner.tax_postal_code,
        tax_country: owner.tax_country,
        // Computed fields
        displayName: contact?.display_name || (contact?.is_company 
          ? contact?.company_name 
          : `${contact?.first_name || ''} ${contact?.last_name || ''}`.trim()) || `Owner ${owner.id.slice(0, 8)}`,
        addressLine1: contact?.primary_address_line_1, // Legacy compatibility
        // Total units calculated from properties
        total_units: owner.total_units || 0
      };
    }) || [];

    console.log('🔍 Owners API: Transformation completed');
    console.log('🔍 Owners API: Final count:', transformedOwners.length);

    // Temporarily disable logger to avoid pino issues
    // logger.info({ count: transformedOwners.length, userId: user.id }, 'Owners fetched successfully');
    return NextResponse.json(transformedOwners)
  } catch (error) {
    console.error('🔍 Owners API: Caught error:', error);
    
    if (error instanceof Error && error.message === 'UNAUTHENTICATED') {
      console.log('🔍 Owners API: Authentication error');
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('🔍 Owners API: Unexpected error:', errorMessage);
    // Temporarily disable logger to avoid pino issues
    // logger.error({ error: errorMessage }, 'Error fetching owners');
    return NextResponse.json(
      { error: 'Failed to fetch owners', details: errorMessage },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    console.log('🔍 Owners API POST: Starting request...');
    
    // Rate limiting
    const rateLimit = await checkRateLimit(request);
    if (!rateLimit.success) {
      console.log('🔍 Owners API POST: Rate limit exceeded');
      return NextResponse.json(
        { error: 'Too many requests', retryAfter: rateLimit.retryAfter },
        { status: 429 }
      );
    }

    console.log('🔍 Owners API POST: Rate limit check passed');

    // Authentication
    console.log('🔍 Owners API POST: Checking authentication...');
    const user = await requireUser(request);
    console.log('🔍 Owners API POST: User authenticated:', user.id);
    // logger.info({ userId: user.id, action: 'create_owner' }, 'Creating new owner');

    const body = await request.json();
    console.log('🔍 Owners API POST: Received body:', body);

    // Validate request body with schema
    const validatedData = sanitizeAndValidate(body, OwnerCreateSchema);
    console.log('🔍 Owners API POST: Validated data:', validatedData);

    // Extract all possible fields from the request
    const { 
      // Contact fields
      firstName, 
      lastName, 
      isCompany = false, 
      companyName, 
      primaryEmail,
      altEmail,
      primaryPhone,
      altPhone,
      dateOfBirth,
      // Primary address
      primaryAddressLine1,
      primaryAddressLine2,
      primaryAddressLine3,
      primaryCity,
      primaryState,
      primaryPostalCode,
      primaryCountry,
      // Alternative address
      altAddressLine1,
      altAddressLine2,
      altAddressLine3,
      altCity,
      altState,
      altPostalCode,
      altCountry,
      mailingPreference,
      // Tax information
      taxPayerId,
      taxPayerType,
      taxPayerName,
      taxAddressLine1,
      taxAddressLine2,
      taxAddressLine3,
      taxCity,
      taxState,
      taxPostalCode,
      taxCountry,
      // Owner-specific fields
      managementAgreementStartDate,
      managementAgreementEndDate,
      comment,
      etfAccountType,
      etfAccountNumber,
      etfRoutingNumber,
      // Legacy support
      email,
      phoneHome,
      phoneMobile,
      addressLine1,
      city,
      state,
      postalCode,
      country
    } = body;

    // Handle legacy field mapping
    const finalPrimaryEmail = primaryEmail || email;
    const finalPrimaryPhone = primaryPhone || phoneMobile || phoneHome;
    const finalPrimaryAddressLine1 = primaryAddressLine1 || addressLine1;
    const finalPrimaryCity = primaryCity || city;
    const finalPrimaryState = primaryState || state;
    const finalPrimaryPostalCode = primaryPostalCode || postalCode;
    const finalPrimaryCountry = primaryCountry || country || 'USA';

    // Validation
    if (isCompany && !companyName) {
      return NextResponse.json(
        { error: 'Company name is required for company owners' },
        { status: 400 }
      );
    }

    if (!isCompany && (!firstName || !lastName)) {
      return NextResponse.json(
        { error: 'First name and last name are required for individual owners' },
        { status: 400 }
      );
    }

    if (!finalPrimaryEmail) {
      return NextResponse.json(
        { error: 'Primary email is required' },
        { status: 400 }
      );
    }

    // Basic email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(finalPrimaryEmail)) {
      return NextResponse.json(
        { error: 'Invalid email format' },
        { status: 400 }
      );
    }

    if (!finalPrimaryAddressLine1 || !finalPrimaryPostalCode) {
      return NextResponse.json(
        { error: 'Primary address line 1 and postal code are required' },
        { status: 400 }
      );
    }

    // Check for existing contact with the same email to prevent duplicates
    console.log('🔍 Owners API POST: Checking for existing contact with email:', finalPrimaryEmail);
    const { data: existingContact, error: contactCheckError } = await supabaseAdmin
      .from('contacts')
      .select('id')
      .ilike('primary_email', finalPrimaryEmail)
      .single();

    if (contactCheckError && contactCheckError.code !== 'PGRST116') {
      console.error('🔍 Owners API POST: Error checking for existing contact:', contactCheckError);
      return NextResponse.json(
        { error: 'Failed to check for existing contact' },
        { status: 500 }
      );
    }

    let contactId: number;

    if (existingContact) {
      console.log('🔍 Owners API POST: Found existing contact:', existingContact.id);
      
      // Check if this contact already has an owner record
      const { data: existingOwner, error: ownerCheckError } = await supabaseAdmin
        .from('owners')
        .select('id')
        .eq('contact_id', existingContact.id)
        .single();

      if (ownerCheckError && ownerCheckError.code !== 'PGRST116') {
        console.error('🔍 Owners API POST: Error checking for existing owner:', ownerCheckError);
        return NextResponse.json(
          { error: 'Failed to check for existing owner' },
          { status: 500 }
        );
      }

      if (existingOwner) {
        return NextResponse.json(
          { error: 'An owner record already exists for this contact' },
          { status: 400 }
        );
      }

      contactId = existingContact.id;
    } else {
      console.log('🔍 Owners API POST: Creating new contact');
      
      // Create new contact
      const contactData = {
        is_company: isCompany,
        first_name: isCompany ? null : firstName,
        last_name: isCompany ? null : lastName,
        company_name: isCompany ? companyName : null,
        // display_name will be auto-generated by the trigger
        primary_email: finalPrimaryEmail,
        alt_email: altEmail,
        primary_phone: finalPrimaryPhone,
        alt_phone: altPhone,
        date_of_birth: dateOfBirth,
        primary_address_line_1: finalPrimaryAddressLine1,
        primary_address_line_2: primaryAddressLine2,
        primary_address_line_3: primaryAddressLine3,
        primary_city: finalPrimaryCity,
        primary_state: finalPrimaryState,
        primary_postal_code: finalPrimaryPostalCode,
        primary_country: finalPrimaryCountry,
        alt_address_line_1: altAddressLine1,
        alt_address_line_2: altAddressLine2,
        alt_address_line_3: altAddressLine3,
        alt_city: altCity,
        alt_state: altState,
        alt_postal_code: altPostalCode,
        alt_country: altCountry,
        mailing_preference: mailingPreference,
        updated_at: new Date().toISOString()
      };

      const { data: newContact, error: contactError } = await supabaseAdmin
        .from('contacts')
        .insert(contactData)
        .select('id')
        .single();

      if (contactError) {
        console.error('🔍 Owners API POST: Error creating contact:', contactError);
        // logger.error({ error: contactError, userId: user.id }, 'Error creating contact');
        return NextResponse.json(
          { error: 'Failed to create contact' },
          { status: 500 }
        );
      }

      contactId = newContact.id;
      console.log('🔍 Owners API POST: Created new contact with ID:', contactId);
    }

    // Create owner record
    console.log('🔍 Owners API POST: Creating owner record with contact_id:', contactId);
    const ownerData = {
      contact_id: contactId,
      management_agreement_start_date: managementAgreementStartDate,
      management_agreement_end_date: managementAgreementEndDate,
      comment: comment,
      etf_account_type: etfAccountType,
      etf_account_number: etfAccountNumber,
      etf_routing_number: etfRoutingNumber,
      // Tax information
      tax_payer_id: taxPayerId,
      tax_payer_type: taxPayerType,
      tax_payer_name: taxPayerName,
      tax_address_line_1: taxAddressLine1,
      tax_address_line_2: taxAddressLine2,
      tax_address_line_3: taxAddressLine3,
      tax_city: taxCity,
      tax_state: taxState,
      tax_postal_code: taxPostalCode,
      tax_country: taxCountry,
      updated_at: new Date().toISOString()
    };

    const { data: newOwner, error: ownerError } = await supabaseAdmin
      .from('owners')
      .insert(ownerData)
      .select(`
        id,
        contact_id,
        management_agreement_start_date,
        management_agreement_end_date,
        comment,
        etf_account_type,
        etf_account_number,
        etf_routing_number,
        tax_payer_id,
        tax_payer_type,
        tax_payer_name,
        tax_address_line_1,
        tax_address_line_2,
        tax_address_line_3,
        tax_city,
        tax_state,
        tax_postal_code,
        tax_country,
        created_at,
        updated_at,
        contacts (
          id,
          is_company,
          first_name,
          last_name,
          company_name,
          primary_email,
          primary_phone,
          primary_address_line_1,
          primary_city,
          primary_state,
          primary_postal_code,
          primary_country
        )
      `)
      .single();

    if (ownerError) {
      console.error('🔍 Owners API POST: Error creating owner:', ownerError);
      // logger.error({ error: ownerError, userId: user.id }, 'Error creating owner');
      return NextResponse.json(
        { error: 'Failed to create owner' },
        { status: 500 }
      );
    }

    // Transform response to match expected format
    const contact = Array.isArray(newOwner.contacts) ? newOwner.contacts[0] : newOwner.contacts;
    const transformedOwner = {
      id: newOwner.id,
      contact_id: newOwner.contact_id,
      management_agreement_start_date: newOwner.management_agreement_start_date,
      management_agreement_end_date: newOwner.management_agreement_end_date,
      comment: newOwner.comment,
      etf_account_type: newOwner.etf_account_type,
      etf_account_number: newOwner.etf_account_number,
      etf_routing_number: newOwner.etf_routing_number,
      created_at: newOwner.created_at,
      updated_at: newOwner.updated_at,
      // Contact information flattened
      is_company: contact?.is_company,
      first_name: contact?.first_name,
      last_name: contact?.last_name,
      company_name: contact?.company_name,
      primary_email: contact?.primary_email,
      primary_phone: contact?.primary_phone,
      primary_address_line_1: contact?.primary_address_line_1,
      primary_city: contact?.primary_city,
      primary_state: contact?.primary_state,
      primary_postal_code: contact?.primary_postal_code,
      primary_country: contact?.primary_country,
      // Tax information from owners table
      tax_payer_id: newOwner.tax_payer_id,
      tax_payer_type: newOwner.tax_payer_type,
      tax_payer_name: newOwner.tax_payer_name,
      tax_address_line_1: newOwner.tax_address_line_1,
      tax_address_line_2: newOwner.tax_address_line_2,
      tax_address_line_3: newOwner.tax_address_line_3,
      tax_city: newOwner.tax_city,
      tax_state: newOwner.tax_state,
      tax_postal_code: newOwner.tax_postal_code,
      tax_country: newOwner.tax_country,
      // Computed fields
      displayName: contact?.is_company 
        ? contact?.company_name 
        : `${contact?.first_name || ''} ${contact?.last_name || ''}`.trim(),
      addressLine1: contact?.primary_address_line_1 // Legacy compatibility
    };

    console.log('🔍 Owners API POST: Owner created successfully:', newOwner.id);
    // logger.info({ ownerId: newOwner.id, contactId: contactId, userId: user.id }, 'Owner created successfully');
    return NextResponse.json(transformedOwner, { status: 201 });
  } catch (error) {
    console.error('🔍 Owners API POST: Caught error:', error);
    console.error('🔍 Owners API POST: Error type:', typeof error);
    console.error('🔍 Owners API POST: Error constructor:', error?.constructor?.name);
    console.error('🔍 Owners API POST: Error stack:', error instanceof Error ? error.stack : 'No stack');
    
    if (error instanceof Error && error.message === 'UNAUTHENTICATED') {
      console.log('🔍 Owners API POST: Authentication error detected');
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('🔍 Owners API POST: Final error message:', errorMessage);
    logger.error({ error: errorMessage }, 'Error creating owner');
    return NextResponse.json(
      { error: 'Failed to create owner', details: errorMessage },
      { status: 500 }
    );
  }
}
